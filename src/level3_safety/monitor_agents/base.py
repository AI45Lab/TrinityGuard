"""Base classes for monitor agents in Level 3."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List

from ...level2_intermediary.structured_logging import AgentStepLog


@dataclass
class Alert:
    """Security alert from a monitor."""
    severity: str  # "info", "warning", "critical"
    risk_type: str
    message: str
    evidence: Dict = field(default_factory=dict)
    recommended_action: str = "log"  # "log", "warn", "block"
    timestamp: Optional[float] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "severity": self.severity,
            "risk_type": self.risk_type,
            "message": self.message,
            "evidence": self.evidence,
            "recommended_action": self.recommended_action,
            "timestamp": self.timestamp
        }


class BaseMonitorAgent(ABC):
    """Abstract base class for runtime monitors."""

    def __init__(self):
        self.config: Dict = {}
        self.state: Dict = {}  # Stateful monitoring

    @abstractmethod
    def get_monitor_info(self) -> Dict[str, str]:
        """Return monitor metadata (name, risk_type, description).

        Returns:
            Dict with keys: name, risk_type, description
        """
        pass

    @abstractmethod
    def process(self, log_entry: AgentStepLog) -> Optional[Alert]:
        """Process a log entry and return alert if risk detected.

        Args:
            log_entry: Structured log from workflow execution

        Returns:
            Alert if risk detected, None otherwise
        """
        pass

    def reset(self):
        """Reset monitor state (called between workflow runs)."""
        self.state = {}

    def configure(self, config: Dict):
        """Configure monitor with custom settings.

        Args:
            config: Configuration dict
        """
        self.config.update(config)

    # === Test-Monitor Linkage Interface ===

    def set_test_context(self, test_results: Dict):
        """Set pre-deployment test results as context for monitoring.

        This allows the monitor to adjust its sensitivity based on
        known vulnerabilities discovered during testing.

        Args:
            test_results: Results from linked risk test
        """
        self.state["test_context"] = test_results
        self.state["known_vulnerabilities"] = []

        # Extract failed test cases as known vulnerabilities
        if "details" in test_results:
            for detail in test_results["details"]:
                if not detail.get("passed", False):
                    self.state["known_vulnerabilities"].append({
                        "test_case": detail.get("test_case", "unknown"),
                        "severity": detail.get("severity", "medium"),
                        "input": detail.get("input", ""),
                        "error": detail.get("error", "")
                    })

    def get_risk_profile(self) -> Dict:
        """Generate a risk profile based on test results and monitoring state.

        Returns:
            Dict with risk assessment including:
            - known_vulnerabilities: List of discovered issues
            - risk_level: Overall risk level (low, medium, high, critical)
            - recommendations: List of recommended actions
        """
        known_vulns = self.state.get("known_vulnerabilities", [])
        alerts = self.state.get("alerts", [])

        # Calculate risk level based on vulnerabilities and alerts
        critical_count = sum(1 for v in known_vulns if v.get("severity") == "critical")
        high_count = sum(1 for v in known_vulns if v.get("severity") == "high")
        alert_count = len(alerts)

        if critical_count > 0 or alert_count > 5:
            risk_level = "critical"
        elif high_count > 0 or alert_count > 2:
            risk_level = "high"
        elif known_vulns:
            risk_level = "medium"
        else:
            risk_level = "low"

        # Generate recommendations
        recommendations = []
        if critical_count > 0:
            recommendations.append("Address critical vulnerabilities before deployment")
        if high_count > 0:
            recommendations.append("Review and remediate high-severity issues")
        if alert_count > 0:
            recommendations.append("Investigate runtime alerts")
        if not recommendations:
            recommendations.append("Continue monitoring")

        return {
            "risk_level": risk_level,
            "known_vulnerabilities": known_vulns,
            "alert_count": alert_count,
            "recommendations": recommendations,
            "monitor_info": self.get_monitor_info()
        }

    def get_alerts_history(self) -> List[Alert]:
        """Get history of all alerts generated by this monitor.

        Returns:
            List of Alert objects
        """
        return self.state.get("alerts", [])

    def _record_alert(self, alert: Alert):
        """Record an alert in the monitor's history.

        Args:
            alert: Alert to record
        """
        if "alerts" not in self.state:
            self.state["alerts"] = []
        self.state["alerts"].append(alert)

