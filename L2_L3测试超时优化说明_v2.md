# L2/L3 测试超时优化说明 v2

## 问题描述

在运行 L2 风险测试时，发现第一个测试用例开始后一直运行不停止，没有在设定的轮数限制下结束。

## 问题分析

L2 和 L3 测试的每个测试用例都会运行一个完整的多智能体工作流（workflow），这个过程可能需要较长时间（30秒到2分钟不等）。之前的实现中，L2 测试没有设置 `max_rounds`（最大对话轮数）和 `timeout`（超时时间）限制，导致工作流可能无限期运行。

## 解决方案 v1（已实现但未生效）

### 修改的文件

**`src/level3_safety/risk_tests/l2_base.py`**

在 `L2AgentWrapperTest` 类中添加了配置参数：

```python
def __init__(self):
    """Initialize L2 Agent Wrapper Test."""
    super().__init__()
    self.config.update({
        # ... 其他配置 ...
        "max_rounds": 10,  # 最大对话轮数
        "workflow_timeout": 300,  # 工作流超时时间（秒）
    })
```

在 `run_single_test()` 方法中使用这些参数：

```python
# 从配置中获取工作流执行参数
max_rounds = self.config.get("max_rounds", 10)
workflow_timeout = self.config.get("workflow_timeout", 300)

# 运行工作流时传递这些参数
workflow_result = intermediary.run_workflow(
    task=task_to_use,
    mode=RunMode.MONITORED_INTERCEPTING,
    interceptions=interceptions,
    silent=True,
    max_rounds=max_rounds,  # 限制对话轮数
    timeout=workflow_timeout  # 设置超时
)
```

## 问题反馈

**用户报告：仍然没有终止，没有在10轮的时候就结束，而是一直运行**

## 调试方案 v2（当前进行中）

### 添加调试日志

为了诊断为什么 `max_rounds` 参数没有生效，我在以下位置添加了调试日志：

#### 1. L2 测试基类 (`src/level3_safety/risk_tests/l2_base.py`)

在 `run_single_test()` 方法中添加：

```python
# 第 461 行
print(f"\n🔍 [L2 Test] Calling run_workflow with max_rounds={max_rounds}, timeout={workflow_timeout}")

# 运行工作流...

# 第 474 行
print(f"🔍 [L2 Test] Workflow completed. Success: {workflow_result.success}, Messages: {len(workflow_result.messages)}")
```

#### 2. AG2 框架包装器 (`src/level1_framework/ag2_wrapper.py`)

在 `_run_group_chat()` 方法中添加：

```python
# 第 199-201 行
self.logger.info(f"🔍 _run_group_chat called with max_rounds={max_rounds}, silent={silent}")
self.logger.info(f"🔍 All kwargs: {kwargs}")

# 第 211 行
self.logger.info(f"🔍 Calling initiate_chat with max_turns={max_rounds}")

# 第 221 行
self.logger.info(f"🔍 initiate_chat completed. Message history length: {len(self._message_history)}")
```

### 参数传递路径

```
L2 Test (l2_base.py)
  └─> intermediary.run_workflow(max_rounds=10, timeout=300)
      └─> MASIntermediary.run_workflow(**kwargs)
          └─> runner = create_runner(mode, **kwargs)
          └─> runner.run(task, **kwargs)
              └─> MonitoredWorkflowRunner.run(**kwargs)
                  └─> self.mas.run_workflow(task, **kwargs)
                      └─> AG2MAS.run_workflow(**kwargs)
                          └─> _run_group_chat(**kwargs)
                              └─> initiator.initiate_chat(
                                      self._manager,
                                      message=task,
                                      max_turns=max_rounds,  # ← 这里
                                      silent=silent
                                  )
```

### 可能的原因

1. **参数未正确传递**
   - 某个环节的 `**kwargs` 没有正确传递参数
   - 需要检查每一层是否都正确传递了参数

2. **AG2 框架参数问题**
   - `initiate_chat()` 的 `max_turns` 参数可能不起作用
   - AG2 可能使用不同的参数名或机制

3. **GroupChat 配置问题**
   - GroupChat 对象在创建时可能有自己的 `max_round` 设置
   - 这个设置可能覆盖了 `initiate_chat()` 的 `max_turns` 参数

4. **模式相关问题**
   - `MONITORED_INTERCEPTING` 模式可能影响参数的使用
   - 消息拦截可能干扰了轮数计数

### 调试步骤

运行测试并观察调试日志：

```bash
python tests/evoagent_bench/test_evoagent_workflows.py --risk-levels L2
```

查看输出中的 🔍 标记，确认：

1. **L2 Test 层**：`max_rounds` 是否正确设置为 10
2. **AG2 Wrapper 层**：`max_rounds` 是否正确传递到 `_run_group_chat()`
3. **initiate_chat 调用**：`max_turns` 参数是否正确传递
4. **完成后**：实际执行了多少条消息

### 预期输出示例

```
🔍 [L2 Test] Calling run_workflow with max_rounds=10, timeout=300
🔍 _run_group_chat called with max_rounds=10, silent=True
🔍 All kwargs: {'max_rounds': 10, 'timeout': 300, 'silent': True, ...}
🔍 Calling initiate_chat with max_turns=10
🔍 initiate_chat completed. Message history length: 20
🔍 [L2 Test] Workflow completed. Success: True, Messages: 20
```

如果看到 `Message history length: 20` 而 `max_turns=10`，说明参数没有生效。

## 可能的解决方案

### 方案 1：检查 GroupChat 配置

如果问题出在 GroupChat 对象的 `max_round` 设置，需要修改：

```python
# 在 create_ag2_mas_from_evoagentx() 或类似的地方
group_chat = GroupChat(
    agents=agents,
    messages=[],
    max_round=10  # ← 确保这里设置了限制
)
```

### 方案 2：使用不同的参数名

AG2 可能使用不同的参数名，需要查阅 AG2 文档或源码。

### 方案 3：手动计数并中断

如果 AG2 不支持轮数限制，可以在消息钩子中手动计数：

```python
class RoundLimitedRunner(MonitoredWorkflowRunner):
    def __init__(self, mas, max_rounds=10, **kwargs):
        super().__init__(mas, **kwargs)
        self.max_rounds = max_rounds
        self.round_count = 0

    def on_message(self, message: Dict) -> Dict:
        self.round_count += 1
        if self.round_count >= self.max_rounds * 2:  # 每轮2条消息
            raise Exception(f"Reached max_rounds limit: {self.max_rounds}")
        return super().on_message(message)
```

## 下一步行动

1. **运行测试**：执行测试并收集调试日志
2. **分析日志**：确认参数传递路径
3. **定位问题**：找出参数失效的具体位置
4. **实施修复**：根据问题原因选择合适的解决方案

## 临时解决方案

如果需要立即停止长时间运行的测试，可以：

1. **使用 Ctrl+C** 中断测试
2. **减少 max_rounds**：将配置改为 `"max_rounds": 3`
3. **使用超时**：虽然 `timeout` 参数也可能不生效，但可以尝试

## 相关文档

- **原始说明**：`L2_L3测试超时优化说明.md`
- **进度显示**：`测试用例进度显示功能说明_v2.md`
- **风险级别过滤**：`风险级别过滤使用说明.md`

---

**版本**: 2.0
**日期**: 2026-02-05
**状态**: 调试中 - 等待日志输出分析
