# 任务背景
当前我们希望建立一个MAS安全框架，实现对任意MAS框架的 事前安全测试 与 runtime安全监控。
具体考虑的风险介绍在`MAS风险层级说明.md`。

# 整体框架设计
我们整体分为若干层，每一层都有对应的抽象类设计，实例就对应某种MAS,自下向上为：

---

# Level 1 MAS框架层
- 这一层是基于某种框架实现的MAS,比如AG2，Langgraph等，目前考虑AG2用于初步搭建与实验。
- 这一层的抽象类为框架相关的MAS类，一个实例对应一个MAS，可以传入任务相关数据启动workflow获取最终report/result,同时预设可以通过该类访问底层的Agent等;

---

# Level 2 MAS中介层
- 这一层的设计目标是对底层MAS框架进行封装，获得**框架无关的统一脚手架与接口**，方便上层调用这些接口进行 事前测试 与 运行时监控。
- 这一层首先有 抽象基类 来规定MAS中介类的各种通用接口，其次大部分热门MAS底层框架未来都会对应一个继承类，在内部封装对应的接口。
- 这一层将会提供 事前安全测试 与 runtime监控 的脚手架，前者对应各种接口，而后者对应运行时的结构化日志文档。

###  **事前安全测试**脚手架
该层抽象类应至少包含以下接口（层级自底向上）：
- Agent点对点通讯：可以与内部Agent进行持久多轮对话（便于单轮，多轮Jailbreak测试）
- 交互级通讯：可以模拟其余Agent,向某一Agent传送信息（便于检查错误信息放大）
- 原始workflow运行：应该有个统一接口可以运行底层MAS的workflow
- 消息干扰：可以根据需要，对workflow内部的消息进行干扰，从而观察后续的运行结果，具体用起来可以 
    - 事先定义：可以 直接注入恶意文本，或者使用 恶意伪装Agent Proxy来根据目的自动生成恶意回复
    - runtime更改 
    - （便于检查恶意传播，消息篡改，群体幻觉，叛逆智能体等）

### **运行时测试**脚手架
- 该脚手架基于 事前安全测试脚手架 的 原始workflow运行 的接口，应该实现下述记录：
    - 任务运行时 的 流式结构化输出
    - 任务完成后 的 轨迹结构化记录
- 该脚手架应实现 两类数据尽可能统一的结构化与清晰
- 从而便于上层的 runtime监控 的各个subagent读取需要的记录

**注：两个脚手架这样的设计可以随时根据需求，增添新的脚手架接口，进而在上层添加新的测试**

---

# Level 3 Safety_MAS层
- 该层基于对 MAS中介层 的封装，内置**Risk Test Library**和**Monitor Agent repository**,获得的是最终实现的，兼具 事前安全测试 与 runtime安全监控 的抽象类 Safety_MAS。
- 设想的使用方式是：
    - 将底层MAS实例传入，内部自动完成 MAS中介层 与 Safety_MAS层 的匹配封装，从而获得Safety_MAS实例。
    - 事前可以选择：
        - 自动选择风险测试
        - 手动选择风险测试
    - 运行时可以选择：
        - 手动选择监控Agent
        - LLM智能选择监控Agent
        - 渐进式披露监控Agent
```python
math_solver = mas_framework(document)
safety_math_solver = Safety_MAS(mas=math_solver)

# 运行事前安全测试 自动选择
safety_math_solver.run_auto_safety_tests()

# 运行事前安全测试 手动选择
safety_math_solver.run_manual_safety_tests(selected_tests=["jailbreak_test", "message_tampering_test"])

# 开启监控，智能选择合适的监控Agent
safety_math_solver.start_runtime_monitoring(auto_select=True)

# 运行任务
result = safety_math_solver.run_task()
```

### 事前测试接口
**目标**:在MAS启用前，进行安全评估，尽可能发现潜在风险，避免风险发生。
##### 实现
我们会维护一个**Risk Test Library**。首先将此前定义的20种风险，封装为统一的接口，每个风险都存储在一个文件夹中，包含：
- 风险测试类定义：继承自 抽象风险测试类 
- 测试用例： 
    - 在静态question提供的环境下，进行风险测试;
    - 调用LLM根据MAS的介绍，自动生成动态question进行风险测试;
- 相关配置文件
- 说明文档
- 工具脚本

并且每一个风险测试类内部，允许自定义测试方法，以Jailbreak测试为例，可能包含DAN测试，角色扮演测试等多种方法，从而便于风险测试类内部的扩展，同时单独文件夹的设计也便于未来新增风险测试。

该接口内部风险测试方法的实现，均基于 MAS中介层 提供的 事前安全测试脚手架 来完成。
##### 使用方式
用户可以选择 LLM智能选择测试风险，或者手动选择测试风险。

### Runtime监控接口
**目标**:在MAS已经启用，执行任务时，进行安全监控，尽可能及时发现风险发生，并进行预警与阻断。
##### 实现
我们会维护一个**Monitor Agent repository**。首先将此前定义的20种风险都封装为统一的监控Agent，每个监控Agent都存储在一个文件夹中，包含：
- 监控Agent类定义：继承自 抽象监控Agent类
- 相关配置文件
- 说明文档
- 工具脚本

并且每一个监控Agent类内部，允许自定义监控方法，以消息篡改监控为例，可能包含关键词检测，语义相似度检测等多种方法，从而便于监控Agent类内部的扩展，同时单独文件夹的设计也便于未来新增监控Agent.

该接口内部监控方法的实现，均基于 MAS中介层 提供的 运行时测试脚手架 也就是 流式结构化输出 与 轨迹结构化记录 来完成。

可以预想，MAS中每一个步骤完成后，都会产出结构化的日志文档，不同责任的监控Agent并行运行，根据需要，读取对应的日志内容，进行风险评估，从而实现对MAS运行时的安全监控。
##### 使用方式
用户可以选择：
- 手动选择需要启用的监控Agent
- LLM智能选择需要启用的监控Agent（静态）
- 渐进式披露：有一个总控监控Agent，实时监控整体运行状态，根据需要，动态启用更多的监控Agent进行更细粒度的监控。

**说明：这里我们的实时以单个agent节点任务完成为单位**


# 任务
请基于以上资料和要求，实现任务，并且底层MAS框架暂时考虑AG2来进行实现，未来再考虑集成更多框架

# 额外要求
- 代码结构清晰
- 鲁棒的异常处理机制
- 丰富的说明

# 优点
- 渐进式披露
- 对于风险层级的三层划分
- 灵活的可扩展性，可以融入各种安全评测方法 和 多智能体框架

