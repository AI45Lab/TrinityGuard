# L2/L3 测试超时问题深度调查报告

## 问题描述

L2 测试在设置 `max_rounds=10` 后仍然执行了 25 轮对话，没有在 10 轮后停止。

## 调查过程

### 1. 参数传递验证

通过添加调试日志，确认了参数传递路径正确：

```
L2 Test → Intermediary → WorkflowRunner → AG2MAS → GroupChat
```

调试日志显示：
```
🔍 [L2 Test] Calling run_workflow with max_rounds=10, timeout=300
🔍 _run_group_chat called with max_rounds=10, silent=True
🔍 Updated GroupChat.max_round from 10 to 10
🔍 Calling initiate_chat with max_turns=10
```

### 2. 实际执行结果

- **设置值**: `max_rounds=10`
- **实际轮数**: 25 轮（通过统计 "Next speaker:" 出现次数）
- **Agent 数量**: 3 个 (pdf_text_extraction_agent, content_analysis_agent, summary_generation_agent)

### 3. 关键发现

#### 发现 1: GroupChat.max_round 优先级

AG2 框架中，`GroupChat.max_round` 参数优先于 `initiate_chat(max_turns=...)` 参数。

**代码位置**: `src/level1_framework/ag2_wrapper.py:202-207`

```python
# CRITICAL FIX: Update GroupChat's max_round before running
# The GroupChat object's max_round takes precedence over initiate_chat's max_turns
if self._group_chat is not None:
    original_max_round = self._group_chat.max_round
    self._group_chat.max_round = max_rounds
    self.logger.info(f"🔍 Updated GroupChat.max_round from {original_max_round} to {max_rounds}")
```

#### 发现 2: max_round 的含义不明确

尽管成功更新了 `GroupChat.max_round = 10`，但工作流仍执行了 25 轮。这说明 **`max_round` 的含义与我们理解的不同**。

可能的解释：
1. **`max_round` 是每个 agent 的最大轮数**，而不是总轮数
2. **`max_round` 的计数方式特殊**，可能只计算某些类型的消息
3. **`max_round` 在某些模式下不生效**，需要其他终止条件

## AG2 框架分析

### GroupChat 参数

```python
GroupChat.__init__(
    agents: list[Agent],
    messages: list[dict] = [],
    max_round: int = 10,  # ← 这个参数的确切含义不明确
    ...
)
```

### initiate_chat 参数

```python
ConversableAgent.initiate_chat(
    recipient: ConversableAgent,
    max_turns: int | None = None,  # ← 在 GroupChat 模式下被忽略
    ...
)
```

## 问题根源

**AG2 的 `max_round` 参数的行为与预期不符**。可能的原因：

1. **文档不清晰**: AG2 文档没有明确说明 `max_round` 的确切含义
2. **计数逻辑复杂**: `max_round` 可能只计算特定类型的消息或轮次
3. **终止条件多样**: GroupChat 可能有多个终止条件，`max_round` 只是其中之一

## 建议的解决方案

### 方案 1: 使用更小的 max_round 值（临时方案）

如果 `max_round` 的实际行为是 "每个 agent 的最大轮数" 或类似逻辑，可以尝试设置更小的值：

```python
# 在 l2_base.py 中
"max_rounds": 3,  # 尝试更小的值
```

**优点**: 简单快速
**缺点**: 不确定具体需要设置多小

### 方案 2: 手动计数并强制终止（推荐）

在消息钩子中手动计数，达到限制后抛出异常强制终止：

```python
class RoundLimitedRunner(MonitoredInterceptingRunner):
    def __init__(self, mas, interceptions, max_rounds=10, **kwargs):
        super().__init__(mas, interceptions, **kwargs)
        self.max_rounds = max_rounds
        self.message_count = 0

    def on_message(self, message: Dict) -> Dict:
        self.message_count += 1
        if self.message_count >= self.max_rounds:
            raise MaxRoundsExceeded(f"Reached max_rounds limit: {self.max_rounds}")
        return super().on_message(message)
```

**优点**:
- 精确控制轮数
- 不依赖 AG2 的 `max_round` 行为

**缺点**:
- 需要修改代码结构
- 需要定义自定义异常

### 方案 3: 使用 timeout 参数（备选）

虽然 `timeout` 参数也传递了，但不确定是否生效。可以尝试设置更短的超时时间：

```python
"workflow_timeout": 60,  # 1 分钟超时
```

**优点**: 简单
**缺点**:
- 基于时间而非轮数
- 可能在正常情况下也会超时

### 方案 4: 深入研究 AG2 源码（长期方案）

查看 AG2 的 GroupChatManager 源码，理解 `max_round` 的确切实现逻辑，然后采取针对性的解决方案。

**优点**: 从根本上解决问题
**缺点**: 需要时间研究源码

## 当前状态

- ✅ 参数传递路径已验证正确
- ✅ GroupChat.max_round 已成功更新
- ❌ max_round 参数未按预期工作
- ❌ 工作流仍执行超过设定轮数

## 下一步行动

### 立即行动（推荐）

1. **实施方案 2**: 创建自定义的 WorkflowRunner，手动计数并强制终止
2. **测试验证**: 运行 L2 测试确认是否能在指定轮数后停止
3. **更新文档**: 记录解决方案和实现细节

### 后续研究

1. **研究 AG2 源码**: 理解 `max_round` 的确切含义和实现
2. **提交 Issue**: 向 AG2 项目提交 Issue，询问 `max_round` 的正确用法
3. **改进方案**: 根据研究结果优化实现

## 相关文件

- `src/level3_safety/risk_tests/l2_base.py` - L2 测试基类
- `src/level1_framework/ag2_wrapper.py` - AG2 框架包装器
- `src/level2_intermediary/workflow_runners/monitored.py` - 监控型 WorkflowRunner
- `src/level2_intermediary/workflow_runners/combined.py` - 组合型 WorkflowRunner

## 测试日志

完整测试日志保存在: `/tmp/l2_test_output.log`

关键统计：
- 设置的 max_rounds: 10
- 实际执行轮数: 25
- Agent 数量: 3
- 测试时间: 约 3 分钟

---

**报告日期**: 2026-02-05
**调查人员**: Claude Code
**状态**: 问题已定位，等待实施解决方案
