# 测试用例进度显示功能 - 更新说明

## 重要说明

### L2/L3 风险测试的特殊性

**L2（智能体间通信）和 L3（系统级）风险测试的每个测试用例都会运行一次完整的工作流！**

这意味着：
- 如果一个 L2 风险有 8 个测试用例
- 每个测试用例都会启动一次完整的多智能体工作流
- 每次工作流可能需要 30 秒到几分钟
- **这是正常的！不是卡住了！**

### 为什么需要运行工作流？

L2/L3 风险测试需要：
1. 拦截智能体之间的消息
2. 注入恶意内容或修改消息
3. 观察系统如何响应
4. 评估系统是否检测到攻击

这个过程必须在真实的工作流执行中进行，所以每个测试用例都需要运行一次工作流。

## 更新内容

### 新的进度回调格式

现在进度回调接收三个参数：

```python
def progress_callback(current: int, total: int, status: str) -> None:
    """
    Args:
        current: 当前测试用例编号（从 1 开始）
        total: 总测试用例数量
        status: 测试用例状态
                - 'starting': 测试用例开始执行
                - 'completed': 测试用例执行完成
                - 'error': 测试用例执行出错
    """
    pass
```

### 新的输出格式

```
[9/20] (45%) Testing message_tampering...
  Test case 1/8: Starting (running workflow)...
  Test case 1/8: Completed
  Test case 2/8: Starting (running workflow)...
  Test case 2/8: Completed
  ...
  Test case 8/8: Starting (running workflow)...
  Test case 8/8: Completed
```

**关键信息**：
- "Starting (running workflow)..." 表示正在运行工作流
- 这个阶段可能需要较长时间（30秒-几分钟）
- 这是正常的，请耐心等待

## 使用示例

### 基本使用

```python
def test_case_progress(current, total, status='running'):
    if status == 'starting':
        print(f"\r  测试用例 {current}/{total}: 开始 (运行工作流)...", end='', flush=True)
    elif status == 'completed':
        print(f"\r  测试用例 {current}/{total}: 完成                  ", end='', flush=True)
    elif status == 'error':
        print(f"\r  测试用例 {current}/{total}: 错误                  ", end='', flush=True)

# 运行测试
result = safety_mas.run_manual_safety_tests(
    ["message_tampering"],
    progress_callback=test_case_progress
)
print()  # 换行
```

### 带时间估算的进度显示

```python
import time

start_times = {}

def test_case_progress(current, total, status='running'):
    if status == 'starting':
        start_times[current] = time.time()
        print(f"\r  测试用例 {current}/{total}: 开始 (运行工作流)...", end='', flush=True)
    elif status == 'completed':
        elapsed = time.time() - start_times.get(current, time.time())
        print(f"\r  测试用例 {current}/{total}: 完成 (耗时 {elapsed:.1f}秒)", end='', flush=True)
    elif status == 'error':
        print(f"\r  测试用例 {current}/{total}: 错误                  ", end='', flush=True)
```

### 带进度条的显示

```python
def test_case_progress(current, total, status='running'):
    percentage = (current / total) * 100
    bar_length = 20
    filled = int(bar_length * current / total)
    bar = '█' * filled + '░' * (bar_length - filled)

    if status == 'starting':
        print(f"\r  [{bar}] {percentage:.0f}% - 测试用例 {current}/{total}: 运行中...", end='', flush=True)
    elif status == 'completed':
        print(f"\r  [{bar}] {percentage:.0f}% - 测试用例 {current}/{total}: 完成    ", end='', flush=True)
    elif status == 'error':
        print(f"\r  [{bar}] {percentage:.0f}% - 测试用例 {current}/{total}: 错误    ", end='', flush=True)
```

## 性能说明

### L1 风险测试（单智能体）
- **速度**: 快速（每个测试用例 1-5 秒）
- **原因**: 只测试单个智能体的响应，不需要运行完整工作流
- **测试用例数**: 通常 5-10 个

### L2 风险测试（智能体间通信）
- **速度**: 较慢（每个测试用例 30 秒-2 分钟）
- **原因**: 需要运行完整的多智能体工作流
- **测试用例数**: 通常 6-8 个
- **总时间**: 3-16 分钟

### L3 风险测试（系统级）
- **速度**: 最慢（每个测试用例 1-3 分钟）
- **原因**: 需要运行完整工作流并观察系统级行为
- **测试用例数**: 通常 4-6 个
- **总时间**: 4-18 分钟

### 完整测试时间估算

运行所有 20 个风险测试：
- **L1 风险（8 个）**: 约 5-10 分钟
- **L2 风险（6 个）**: 约 20-60 分钟
- **L3 风险（6 个）**: 约 25-70 分钟
- **总计**: 约 50-140 分钟（1-2.5 小时）

## 优化建议

### 1. 使用 --no-llm-judge 加速

```bash
python tests/evoagent_bench/test_evoagent_workflows.py --no-llm-judge
```

- 使用启发式规则代替 LLM 评估
- 可以节省 30-50% 的时间
- 适合快速测试

### 2. 只测试特定风险

```bash
python tests/evoagent_bench/test_evoagent_workflows.py \
    --monitors jailbreak prompt_injection
```

- 只运行指定的风险测试
- 大幅减少测试时间
- 适合针对性测试

### 3. 分批测试

```bash
# 只测试 L1 风险（快速）
python tests/evoagent_bench/test_evoagent_workflows.py \
    --monitors jailbreak prompt_injection sensitive_disclosure \
              excessive_agency code_execution hallucination \
              memory_poisoning tool_misuse

# 只测试 L2 风险（中等）
python tests/evoagent_bench/test_evoagent_workflows.py \
    --monitors message_tampering malicious_propagation \
              misinformation_amplify insecure_output \
              goal_drift identity_spoofing

# 只测试 L3 风险（慢速）
python tests/evoagent_bench/test_evoagent_workflows.py \
    --monitors cascading_failures sandbox_escape \
              insufficient_monitoring group_hallucination \
              malicious_emergence rogue_agent
```

## 故障排查

### 问题 1: 测试用例一直显示 "Starting"

**现象**:
```
Test case 3/8: Starting (running workflow)...
```
长时间不变

**原因**: 工作流正在执行，这是正常的

**解决**:
- 耐心等待（L2/L3 测试需要时间）
- 检查工作流是否有死循环
- 查看日志文件了解详细执行情况

### 问题 2: 测试时间过长

**原因**: L2/L3 测试需要运行完整工作流

**解决**:
- 使用 `--no-llm-judge` 加速
- 减少测试的风险数量
- 优化工作流配置（减少 max_rounds）

### 问题 3: 进度显示不更新

**原因**: 输出缓冲

**解决**: 确保使用 `flush=True`

```python
print(f"\r  进度: {current}/{total}", end='', flush=True)
```

## 技术细节

### L2 测试的工作流程

1. **加载测试用例** - 从 test_cases.json 读取
2. **对每个测试用例**:
   - 创建消息拦截器
   - 配置消息修改函数（注入攻击载荷）
   - **运行完整工作流**（这里最耗时）
   - 收集工作流输出和消息
   - 使用 Judge 评估结果
   - 判断系统是否检测到攻击

### 为什么不能并行？

L2/L3 测试不能并行执行，因为：
- 每个测试需要独立的工作流实例
- 消息拦截器会相互干扰
- LLM API 有速率限制
- 资源消耗过大

## 相关文档

- **执行流程文档**: `tests/evoagent_bench/执行流程文档.md`
- **README**: `tests/evoagent_bench/README.md`
- **L2 基类**: `src/level3_safety/risk_tests/l2_base.py`

---

**版本**: 2.0
**日期**: 2026-02-05
**更新**: 添加状态参数，说明 L2/L3 测试的特殊性
